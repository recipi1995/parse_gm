Парсер достопримечательностей с карт google maps
Для запуска проекта необходимо скачать chromium (возможно использование и другого браузера, но тестирование проводилось именно на этом браузере в системе Windows 10), скачать драйвер для браузера chromium (причем версия браузера и драйвера для него должны совпадать) и поместить все это в папку с проектом (https://chromedriver.chromium.org/downloads). 
У меня название папки с драйвером и файлом были в таком формате: "chrome-win/", "chromium.exe". Если у вас отличаются то можно изменить в файле config.py.
Все остально необходимое для работы уже есть в папке с проектом, а так же примеры в файле excel уже собранных данных по стране Италия.
Перед запуском программы необходимо открыть config.py  и обратить внимание на словарь DICT_CITIES  со списком стран и городов, эти списки можно редактировать по своему усмотрению соблюдая данный шаблон. Так же я для удобства я разбил страны попарно, продублировал словари и заккоментировал, после прохода по первым двум странам, можно заккоментировать пройденый словарь и раскомментировать необходимый.
Так же в файле config.py есть список PLACE_TYPE с типом достопримечательнойстей которые по которым скрипт будет искать организации, Вы можете отредактировать его по своему усмотрению, сохраняя целостность шаблона.
В том же файле можно отредактировать BINARY_LOCATION и BROWSER в которых содержатся пути к драйверу и к самому браузеру.
Для запуска скрипта необхоидмо запустить файлик start.py.
Скрипт собирает данные по порядку для каждого города каждой страны в списке по порядку.
После запуска скрипт заработает в одном из трех режимов, которые являются этапами: gather | collect | excel_write, при настройках по умолчанию они будут выполнять последовательно, но при желании их возможно запустить отдельно.
Первый режим gather имеет следующую структуру работы:
1. Запускается браузер 
2. Состовляется поисковый запрос в формате "https://www.google.com/maps/search/{place_value}+{city_value}+,+{country_value}/"
place_value - значение берется из списка по порядку для каждого города каждой страны
city_value, country_value- значение города и страны, берется из словаря с данными о городах по странам
3. Производится переход по сформированной ссылке
4. Скрипт проходит и собирает из каждого значения найденного по поисковому запросу на каждой странице запроса поиска url адресс организации в google maps и название, пока страницы не закончатся.
5. Создается файл в формате "city_value.json" и в него передаются собранные данные.
6. После сбора данных для каждого поискового запроса экземпляр браузера закрывается.

Далее запускается режим collect и он имеет следующую структуру:
1. Открывается браузер 
2. Берется url адресс каждой организации из файла "city_value.json" по порядку и выполняется переход по нему.
3. Происходит сбор всех оставших данныех по каждой организации и происходит обновление файла "city_value.json".
4. В корне проекта создаются папки data\photos\country_value\city_value\name_of_organisation и туда загружаются фотографии.
5. После сбора данных для каждого url экземпляр браузера закрывается.
6. После сбора данных по всем организациям каждого города данные отсеиваются по параметру buissnes status и перезаписываются в новый файл "city_value_updated.json"
7. В будующем есть возможность сравнить количество организаций собранных изначально и получившихся в результате отсеивания запустив скрипт check_json.py

Далее запускается режим excel_write и он имеет следующую структуру:
1. Создаются папки и файл по пути  data\excel\country_value\city_value.excel по шаблону template.excel, который находится по следующему пути data\excel (обратите внимание, что файл обязательно должен находится по данному пути)
2. В созданный выше файл .excel записываются данные из файла "city_value_updated.json" в соответствии с полями в шаблоне.

Далее все вышеописанные действия проходят для каждого города каждой страны.

Данный скрипт можно запустить на любой операционной системе и с браузерами chrome и firefox, необходимо лишь отредактировать пути к файлам драевера и браузера в config.py и подобрать соответствующие драйвера.